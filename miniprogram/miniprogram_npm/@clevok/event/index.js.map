{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * 获取响应之前上一个路由, 不建议使用这个\r\n * @return {String} route\r\n */\r\nfunction getEmitBeforeRoute() {\r\n    try {\r\n        var routes = getCurrentPages();\r\n        if (!routes)\r\n            return null;\r\n        var l = routes.length;\r\n        if (l === 1 || !l) {\r\n            return null;\r\n        }\r\n        return routes[l - 2].route || routes[l - 2].__route__ || null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nvar Event = /** @class */ (function () {\r\n    function Event() {\r\n        /** 存储 */\r\n        this._events = new Map();\r\n    }\r\n    /** 切换命名空间 */\r\n    Event.use = function (moduleName) {\r\n        if (moduleName === void 0) { moduleName = 'default'; }\r\n        if (this._EventMap.has(moduleName)) {\r\n            return this._EventMap.get(moduleName);\r\n        }\r\n        var event = new Event();\r\n        this._EventMap.set(moduleName, event);\r\n        return event;\r\n    };\r\n    Event.prototype.use = function (moduleName) {\r\n        if (moduleName === void 0) { moduleName = 'default'; }\r\n        return Event.use(moduleName);\r\n    };\r\n    /**\r\n     * 注册前准备工作\r\n     * @param name - 事件名\r\n     * @param callback\r\n     * @param self\r\n     */\r\n    Event.prototype.beforeOn = function (name, callback, self) {\r\n        if (self === void 0) { self = '_default'; }\r\n        if (!name) {\r\n            return console.error('缺失监听事件名称');\r\n        }\r\n        if (!callback) {\r\n            return console.error('空回调函数' + name);\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * 订阅\r\n     * @param {String} name - 事件名\r\n     * @param {Function} callback - 回调函数\r\n     * @param {Object} self - 唯一标识\r\n     */\r\n    Event.prototype.on = function (name, callback, self) {\r\n        var _this = this;\r\n        if (self === void 0) { self = '_default'; }\r\n        if (!this.beforeOn(name, callback, self)) {\r\n            return;\r\n        }\r\n        var temp = [callback, self];\r\n        var events = this._events.get(name);\r\n        if (!events) {\r\n            events = [temp];\r\n            this._events.set(name, events);\r\n        }\r\n        else {\r\n            events.unshift(temp);\r\n        }\r\n        return {\r\n            abort: function () {\r\n                _this.off(name, self);\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * 响应一次后移除\r\n     * @param {String} name - 事件名\r\n     * @param {Function} callback - 回调函数\r\n     * @param {Object} self - 唯一标识\r\n     */\r\n    Event.prototype.once = function (name, callback, self) {\r\n        var _this = this;\r\n        if (self === void 0) { self = '_default'; }\r\n        if (!this.beforeOn(name, callback, self)) {\r\n            return;\r\n        }\r\n        var _callback = function () {\r\n            var arg = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                arg[_i] = arguments[_i];\r\n            }\r\n            callback.apply(self, arg);\r\n            _this.off(name, self);\r\n        };\r\n        return this.on(name, _callback, self);\r\n    };\r\n    /**\r\n     * 相同this只能订阅一个, 后一个覆盖前一个, 并把之前的给覆盖掉\r\n     * @param {String} name 监听事件名称\r\n     * @param {Function} callback 回调函数\r\n     * @param {any} self 唯一标识\r\n     */\r\n    Event.prototype.onnewest = function (name, callback, self) {\r\n        if (self === void 0) { self = '_default'; }\r\n        if (!this.beforeOn(name, callback, self)) {\r\n            return;\r\n        }\r\n        var eventList = this._events.get(name);\r\n        if (!eventList)\r\n            return this.on(name, callback, self);\r\n        var findIndex = eventList.findIndex(function (event) {\r\n            if (event[1] === self)\r\n                return true;\r\n            return false;\r\n        });\r\n        if (findIndex !== -1) {\r\n            eventList.splice(findIndex, 1);\r\n        }\r\n        eventList.unshift([callback, self]);\r\n    };\r\n    /**\r\n     * 相同this下已存在, 不允许被覆盖\r\n     * @param {String} name 监听事件名称\r\n     * @param {Function} callback 回调函数\r\n     * @param {Object} self 唯一标识\r\n     */\r\n    Event.prototype.onoldest = function (name, callback, self) {\r\n        if (self === void 0) { self = '_default'; }\r\n        if (!this.beforeOn(name, callback, self)) {\r\n            return;\r\n        }\r\n        var eventList = this._events.get(name);\r\n        if (!eventList)\r\n            return this.on(name, callback, self);\r\n        var findIndex = eventList.findIndex(function (event) {\r\n            if (event[1] === self)\r\n                return true;\r\n            return false;\r\n        });\r\n        if (findIndex !== -1) {\r\n            return;\r\n        }\r\n        eventList.unshift([callback, self]);\r\n    };\r\n    /**\r\n     * (名字取错了,建议用off)\r\n     * 删除标识, 小心了,和外面的不太一, 不是传入回调函数, 而是传入self\r\n     * @param {String} name\r\n     * @param {Object} self\r\n     */\r\n    Event.prototype.remove = function (name, self) {\r\n        if (self === void 0) { self = '_default'; }\r\n        if (!name || !self)\r\n            return console.error('缺少移除参数');\r\n        var eventList = this._events.get(name);\r\n        if (!eventList || eventList.length <= 0) {\r\n            return;\r\n        }\r\n        return eventList.forEach(function (event, index) {\r\n            if (event[1] === self) {\r\n                eventList && eventList.splice(index, 1);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     *\r\n     * 删除标识, 小心了,和外面的不太一, 不是传入回调函数, 而是传入self\r\n     * 我也不知道这样好不好, 只是感觉这样更加的方便, 在小程序中, 大部分监听只是个普通函数, 要移除只能根据on的回调,或者回调函数移除,太过麻烦\r\n     * 之后是想把event切入page,compontent,拦截销毁事件, 自动移除身上所有的事件\r\n     *\r\n     * @param {String} name\r\n     * @param {Object} self\r\n     */\r\n    Event.prototype.off = function (name, self) {\r\n        if (self === void 0) { self = '_default'; }\r\n        return this.remove(name, self);\r\n    };\r\n    /**\r\n     * 响应\r\n     * @param event\r\n     * @param index\r\n     * @param params\r\n     */\r\n    Event.prototype.callEvent = function (event, index, params) {\r\n        if (!event)\r\n            return;\r\n        var caller = __spreadArrays(params, [\r\n            {\r\n                index: index,\r\n                beforeRoute: getEmitBeforeRoute()\r\n            }\r\n        ]);\r\n        return event[0].apply(event[1], caller);\r\n    };\r\n    /**\r\n     * 特殊,只给最后注册的人发送通知\r\n     * @param {string} name\r\n     * @param {object} arg 额外参数\r\n     */\r\n    Event.prototype.emit = function (name) {\r\n        var arg = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            arg[_i - 1] = arguments[_i];\r\n        }\r\n        var events = this._events.get(name);\r\n        events && this.callEvent(events[0], 0, arg);\r\n    };\r\n    /**\r\n     * 最后注册的,最先被监听\r\n     * @param {string} name\r\n     * @param {object} arg 额外参数\r\n     */\r\n    Event.prototype.emitAll = function (name) {\r\n        var _this = this;\r\n        var arg = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            arg[_i - 1] = arguments[_i];\r\n        }\r\n        var events = this._events.get(name);\r\n        events && events.forEach(function (event, index) {\r\n            _this.callEvent(event, index, arg);\r\n        });\r\n    };\r\n    /** 存储event */\r\n    Event._EventMap = new Map();\r\n    return Event;\r\n}());\r\nexports.Event = Event;\r\nexports.default = Event.use();\r\n"]}